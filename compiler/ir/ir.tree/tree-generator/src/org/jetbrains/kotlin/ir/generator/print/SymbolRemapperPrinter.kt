/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.generator.print

import org.jetbrains.kotlin.generators.tree.*
import org.jetbrains.kotlin.generators.tree.printer.*
import org.jetbrains.kotlin.ir.generator.*
import org.jetbrains.kotlin.ir.generator.model.Element
import org.jetbrains.kotlin.ir.generator.model.Field.SymbolFieldRole
import org.jetbrains.kotlin.ir.generator.model.ListField
import org.jetbrains.kotlin.util.capitalizeDecapitalize.capitalizeAsciiOnly
import org.jetbrains.kotlin.utils.SmartPrinter
import org.jetbrains.kotlin.utils.addToStdlib.ifNotEmpty
import java.io.File

internal abstract class AbstractSymbolRemapperPrinter(
    private val printer: SmartPrinter,
    val elements: List<Element>,
    val roles: List<SymbolFieldRole>,
) {
    private data class FieldWithSymbol(
        val symbolType: ClassRef<*>,
        val fieldName: String,
        val role: SymbolFieldRole,
        val fieldContainer: ClassOrElementRef,
    )

    companion object {
        private val additionalSymbolFields = listOf(
            FieldWithSymbol(classifierSymbolType, "classifier", SymbolFieldRole.REFERENCED, irSimpleTypeType),
            FieldWithSymbol(typeAliasSymbolType, "typeAlias", SymbolFieldRole.REFERENCED, irTypeAbbreviationType)
        )
    }

    abstract val symbolRemapperType: ClassRef<*>

    abstract val implementationKind: ImplementationKind

    open val symbolRemapperSuperTypes: List<ClassRef<*>>
        get() = emptyList()

    open val kDoc: String?
        get() = null

    context(ImportCollector)
    private fun SmartPrinter.printMethod(symbolType: ClassRef<*>, role: SymbolFieldRole) {
        val symbolParameter = FunctionParameter("symbol", symbolType)
        val elementName = symbolType.simpleName.removePrefix("Ir").removeSuffix("Symbol")
        printFunctionDeclaration(
            "get${role.name.lowercase().capitalizeAsciiOnly()}$elementName",
            parameters = listOf(symbolParameter),
            returnType = symbolType,
            override = symbolRemapperSuperTypes.isNotEmpty(),
        )
        printMethodImplementation(symbolParameter, role)
    }

    context(ImportCollector)
    protected open fun SmartPrinter.printMethodImplementation(symbolParameter: FunctionParameter, role: SymbolFieldRole) {
        println()
    }

    context(ImportCollector)
    protected open fun SmartPrinter.printAdditionalDeclarations() {}

    private val Element.fieldsWithSymbols: List<FieldWithSymbol>
        get() = allFields.mapNotNull { field ->
            val role = field.symbolFieldRole ?: return@mapNotNull null
            val symbolType = if (field is ListField) {
                field.baseType
            } else {
                field.typeRef
            } as? ClassRef<*> ?: return@mapNotNull null
            FieldWithSymbol(symbolType.copy(nullable = false), field.name, role, this)
        }

    context(ImportCollector)
    fun printSymbolRemapper() {
        printer.run {
            printKDoc(
                buildString {
                    kDoc?.let {
                        append(it)
                        appendLine()
                        appendLine()
                    }
                    append("Auto-generated by [${this@AbstractSymbolRemapperPrinter::class.qualifiedName}]")
                },
            )
            assert(symbolRemapperType.kind == implementationKind.typeKind) { "Type kind mismatch" }
            print(implementationKind.title, " ", symbolRemapperType.simpleName)
            symbolRemapperSuperTypes.ifNotEmpty {
                print(joinToString(prefix = " : ") { it.render() + if (it.kind == TypeKind.Class) "()" else "" })
            }
            printBlock {
                val elementSymbolFields = elements.flatMap { element ->
                    if (element.isLeaf) {
                        element.fieldsWithSymbols
                    } else {
                        emptyList()
                    }
                }
                for (role in roles) {
                    val allSymbolFields = (elementSymbolFields + additionalSymbolFields)
                        .filter { it.role == role }
                        .groupBy { it.symbolType }
                    for ((symbolType, fields) in allSymbolFields) {
                        println()
                        if (symbolRemapperSuperTypes.isEmpty()) {
                            val kDoc = buildString {
                                append("Remaps symbols stored in the following properties:")
                                for ((_, fieldName, _, element) in fields) {
                                    addImport(element)
                                    appendLine()
                                    append("- [${element.typeName}.$fieldName]")
                                }
                            }
                            printKDoc(kDoc)
                        }
                        printMethod(symbolType, role)
                    }
                }
                printAdditionalDeclarations()
            }
        }
    }
}

internal class DeclaredSymbolRemapperInterfacePrinter(
    printer: SmartPrinter,
    elements: List<Element>,
    override val symbolRemapperType: ClassRef<*>,
) : AbstractSymbolRemapperPrinter(printer, elements, roles = listOf(SymbolFieldRole.DECLARED)) {
    override val implementationKind: ImplementationKind
        get() = ImplementationKind.Interface

    override val kDoc: String
        get() = "Used to replace declarations' own symbols with new ones."
}

internal class ReferencedSymbolRemapperInterfacePrinter(
    printer: SmartPrinter,
    elements: List<Element>,
    override val symbolRemapperType: ClassRef<*>,
) : AbstractSymbolRemapperPrinter(printer, elements, roles = listOf(SymbolFieldRole.REFERENCED)) {
    override val implementationKind: ImplementationKind
        get() = ImplementationKind.Interface

    override val kDoc: String
        get() = "Used to replace symbols that represent references to declarations other than the symbol's owner."
}

internal class SymbolRemapperInterfacePrinter(
    printer: SmartPrinter,
    elements: List<Element>,
    override val symbolRemapperType: ClassRef<*>,
) : AbstractSymbolRemapperPrinter(printer, elements, roles = emptyList()) {
    override val implementationKind: ImplementationKind
        get() = ImplementationKind.Interface

    override val symbolRemapperSuperTypes: List<ClassRef<*>>
        get() = listOf(declaredSymbolRemapperType, referencedSymbolRemapperType)

    context(ImportCollector)
    override fun SmartPrinter.printAdditionalDeclarations() {
        println()
        EmptySymbolRemapperPrinter(this, elements).printSymbolRemapper()
    }
}

private class EmptySymbolRemapperPrinter(
    printer: SmartPrinter,
    elements: List<Element>,
) : AbstractSymbolRemapperPrinter(printer, elements, listOf(SymbolFieldRole.DECLARED, SymbolFieldRole.REFERENCED)) {

    override val symbolRemapperType = emptySymbolRemapperType

    override val symbolRemapperSuperTypes: List<ClassRef<*>>
        get() = listOf(org.jetbrains.kotlin.ir.generator.symbolRemapperType)

    override val implementationKind: ImplementationKind
        get() = ImplementationKind.OpenClass

    override val kDoc: String
        get() = "The default implementation of [${org.jetbrains.kotlin.ir.generator.symbolRemapperType.simpleName}]\n" +
                "that just keeps the old symbols everywhere."

    context(ImportCollector)
    override fun SmartPrinter.printMethodImplementation(
        symbolParameter: FunctionParameter,
        role: SymbolFieldRole
    ) {
        println(" = ", symbolParameter.name)
    }
}

internal fun printSymbolRemapper(
    generationPath: File,
    model: Model<Element>,
    type: ClassRef<*>,
    makePrinter: (SmartPrinter, List<Element>, ClassRef<*>) -> AbstractSymbolRemapperPrinter,
) = printGeneratedType(generationPath, TREE_GENERATOR_README, type.packageName, type.simpleName) {
    makePrinter(this, model.elements, type).printSymbolRemapper()
}
